package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go.bog.dev/multimain"
	"io"
	"os"
	"os/exec"
	"strings"
	"text/template"
	"time"
)

var mainMapping = multimain.MappingFromMap(map[string]func(){
	"from-dirs": generateFromDirs,
})

var fromDirsTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by multimain at {{ .Timestamp }}
package {{ .Package.Name }}

import (
	"go.bog.dev/multimain"
{{- range .Packages }}
	"{{ .ImportPath }}"
{{- end }}
)

var generatedMultimainMapping = multimain.MappingFromMap(map[string]func(){
{{- range .Packages }}
	"{{ .DirName }}": {{ .Name }}.Main,
{{- end }}
})
`))

type listPackageResult struct {
	Dir        string
	ImportPath string
	Name       string
	Match      []string

	DirName	   string
}

func listSubPackages() ([]*listPackageResult, *listPackageResult, error) {
	cmd := exec.Command("go", "list", "-json", "-e", "-find", ".", "./...")
	output, err := cmd.Output()
	if err != nil {
		var exitErr *exec.ExitError
		if errors.As(err, &exitErr) {
			return nil, nil, fmt.Errorf("%w: %v", err, string(exitErr.Stderr))
		} else {
			return nil, nil, err
		}
	}

	decoder := json.NewDecoder(bytes.NewReader(output))
	var res []*listPackageResult
	var currentPackage *listPackageResult

itemLoop:
	for {
		var item listPackageResult
		err := decoder.Decode(&item)
		if err == io.EOF {
			break
		} else if err != nil {
			return nil, nil, err
		}

		for _, match := range item.Match {
			if match == "." {
				currentPackage = &item
				continue itemLoop
			}
		}

		res = append(res, &item)
	}

	for i := 0; i < len(res); i++ {
		item := res[i]
		item.DirName = strings.Trim(strings.TrimPrefix(item.Dir, currentPackage.Dir), string(os.PathSeparator))
		if strings.ContainsRune(item.DirName, os.PathSeparator) {
			res = append(res[:i], res[i+1:]...)
			i--
		}
	}

	return res, currentPackage, nil
}

func generateFromDirs() {
	packages, currentPackage, err := listSubPackages()
	if err != nil {
		panic(err)
	}

	f, err := os.Create("generated-multimain.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = fromDirsTemplate.Execute(f, map[string]interface{}{
		"Packages":  packages,
		"Package":   currentPackage,
		"Timestamp": time.Now(),
	})
	if err != nil {
		panic(err)
	}
}

func main() {
	multimain.Main(mainMapping, multimain.FromCmdline())
}
